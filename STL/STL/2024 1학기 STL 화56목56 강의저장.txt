

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << "\n";
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	out << "\n" << "\n";
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << "\n";
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	out << "\n" << "\n";
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << "\n";
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	out << "\n" << "\n";
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}
=========================================================
저장한 시간: 
=========================================================



//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << '\n';
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 현재 time_point를 얻는다.
	auto now = std::chrono::system_clock::now();	// epoch으로부터 흐른 tick
	std::cout << now << '\n';
	// 시간형식으로 변환
	// 현지 시간으로 변환
	// 한국형식으로 출력한다. 

	out << '\n';
	out << "=========================================================" << '\n';
	out << "저장한 시간: " << '\n';
	out << "=========================================================" << '\n';
	out << '\n';

	out << "\n\n";
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}
=========================================================
저장한 시간:  2024-03-07 목요일 오후 1:46:54
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << '\n';
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 현재 time_point를 얻는다.
	auto now = std::chrono::system_clock::now();	// epoch으로부터 흐른 tick

	// UTC 시간형식으로 변환
	auto utc = std::chrono::system_clock::to_time_t(now);

	// 현지 시간으로 변환
	auto It = localtime(&utc);	//c 함수

	// 한국형식으로 출력한다. (출력스트림의 지역을 변환)
	auto old = out.imbue(std::locale("ko_KR"));
	
	// 시간을 기록한다.
	out << '\n';
	out << "=========================================================" << '\n';
	out << "저장한 시간: " << std::put_time(It, " %x %A %X") << '\n';
	out << "=========================================================" << '\n';
	out << '\n';

	out.imbue(old); // 이용하고 돌려줘야함.

	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}
=========================================================
저장한 시간:  2024-03-07 목요일 오후 1:50:10
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 5일 화요일		(1주 1)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

void save(std::string_view);

int main(void)
{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

void save(std::string_view fileName)
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << '\n';
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 현재 time_point를 얻는다.
	auto now = std::chrono::system_clock::now();	// epoch으로부터 흐른 tick

	// UTC 시간형식으로 변환
	auto utc = std::chrono::system_clock::to_time_t(now);

	// 현지 시간으로 변환
	auto It = localtime(&utc);	//c 함수

	// 한국형식으로 출력한다. (출력스트림의 지역을 변환)
	auto old = out.imbue(std::locale("ko_KR"));
	
	// 시간을 기록한다.
	out << '\n';
	out << "=========================================================" << '\n';
	out << "저장한 시간: " << std::put_time(It, " %x %A %X") << '\n';
	out << "=========================================================" << '\n';
	out << '\n';

	out.imbue(old); // 이용하고 돌려줘야함.

	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}
=========================================================
STL.cpp 2024-03-07 목요일 오후 1:53:28
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 7일 목요일		(1주 2)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <chrono>

void save(std::string_view);

//-------------
int main(void)
//-------------

{
	std::cout << "2024 STL" << '\n';
	save("STL.cpp");
}

//-----------------------------------
void save(std::string_view fileName)
//-----------------------------------
{
	// fileName을 읽기
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << '\n';
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };
	
	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 현재 time_point를 얻는다.
	auto now = std::chrono::system_clock::now();	// epoch으로부터 흐른 tick
	// UTC 시간형식으로 변환
	auto utc = std::chrono::system_clock::to_time_t(now);
	// 현지 시간으로 변환
	auto It = localtime(&utc);	//c 함수
	// 한국형식으로 출력한다. (출력스트림의 지역을 변환)
	auto old = out.imbue(std::locale("ko_KR"));
	
	// 시간을 기록한다.
	out << '\n';
	out << "=========================================================" << '\n';
	out << fileName << std::put_time(It, " %x %A %X") << '\n';
	out << "=========================================================" << '\n';
	out << '\n';

	out.imbue(old); // 이용하고 돌려줘야함.

	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}

=========================================================
save.h:, 2024-03-07 목요일 오후 2:07:37
=========================================================

//-------------------------------------------------------------------
// save.h		한학기 강의를 저장한다.
// 
// 2024. 3. 7
//-------------------------------------------------------------------
#pragma once

void save(std::string_view);

=========================================================
save.cpp:, 2024-03-07 목요일 오후 2:07:37
=========================================================

//-------------------------------------------------------------------
// save.cpp		한학기 강의를 저장한다.
// 
// 2024. 3. 7
//-------------------------------------------------------------------
#include <string_view>
#include <fstream>
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>
#include "save.h"

//-----------------------------------
void save(std::string_view fileName)
//-----------------------------------
{
	// fileName을 읽기용으로 연다.
	std::ifstream in{ fileName.data() };	//RAII
	if (not in) {
		std::cout << fileName << " 열기 실패" << '\n';
		exit(0);
	}

	// 저장할 파일을 덧붙여 쓰기모드로 연다.
	std::ofstream out{ "2024 1학기 STL 화56목56 강의저장.txt", std::ios::app };

	// 읽을 파일의 내용을 읽어 쓸 파일에 덧붙인다.
	// STL 자료구조와 알고리즘을 이용하여 기록한다. (좋은건 아니다)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 현재 time_point를 얻는다.
	auto now = std::chrono::system_clock::now();	// epoch으로부터 흐른 tick
	// UTC 시간형식으로 변환
	auto utc = std::chrono::system_clock::to_time_t(now);
	// 현지 시간으로 변환
	auto It = localtime(&utc);	//c 함수

	// 한국형식으로 출력한다. (출력스트림의 지역을 변환)
	auto old = out.imbue(std::locale("ko_KR"));

	// 시간을 기록한다.
	out << '\n' << '\n';
	out << "=========================================================" << '\n';
	out << fileName << std::put_time(It, ":, %x %A %X") << '\n';
	out << "=========================================================" << '\n';
	out << '\n';

	out.imbue(old); // 이용하고 돌려줘야함.

	std::copy(v.begin(), v.end(), std::ostreambuf_iterator<char>{ out });
}

=========================================================
STL.cpp:, 2024-03-07 목요일 오후 2:07:37
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 7일 목요일		(1주 2)
// 
// VisualStudio 17.9 이상, Release/x64
// 프로젝트 설정 - 언어 /std:c++latest
//				 - C++언어 SDL 검사 - no
// 
// 한학기 강의를 저장할 save 함수 작성하고 파일 분리
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	std::cout << "save 기능을 완성했다." << '\n';
	save("save.h");
	save("save.cpp");
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-07 목요일 오후 2:28:18
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 7일 목요일		(1주 2)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] main()을 손대지 말고 의도대로 실행되도록 change()를 선언하고 정의하라

void change(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}

//-------------
int main(void)
//-------------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << '\n';	// 2, 1

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-07 목요일 오후 2:28:50
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 7일 목요일		(1주 2)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] main()을 손대지 말고 의도대로 실행되도록 change()를 선언하고 정의하라

template <typename T>
void change(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

//-------------
int main(void)
//-------------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << '\n';	// 2, 1

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-07 목요일 오후 3:00:41
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 7일 목요일		(1주 2)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] main()을 손대지 말고 의도대로 실행되도록 change()를 선언하고 정의

class Dog
{
private:
	int num;
public:
	Dog(int n) : num(n) {}
	friend std::ostream& operator<<(std::ostream& os, Dog n);
};

std::ostream& operator<<(std::ostream& os, Dog n)
{
	os << n.num;
	return os;
}

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

//-------------
int main(void)
//-------------
{
	Dog a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << '\n';	// 2, 1

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:03:12
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 99999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		std::cout << a[i] << '\n';
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:05:36
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		std::cout << std::format("{:8}", a[i]) << '\n';
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:05:58
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		std::cout << std::format("{:8}", a[i]);
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:07:43
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		std::print(std::cout, "{:8}", a[i]);
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:13:40
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[1000];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:13:54
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:16:05
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.
	int max = 0;

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	for (int& num : a)
		if (max < num)
			max = num;
	std::cout << "가장 큰 값: " << max << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:17:12
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.
	int max = 0;

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	for (int& num : a)
		if (max < num)
			max = num;

	std::cout << '\n' << "가장 큰 값: " << max << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:33:38
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.
	int max = 0;

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	std::max_element(std::begin(a), std::end(a));

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:35:35
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.
	int max = 0;

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	auto pos = std::max_element(std::begin(a), std::end(a));
	std::cout << "최대값: " << *pos << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:36:15
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.
	int max = 0;

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	std::cout << "최대값: " << *std::max_element(std::begin(a), std::end(a)) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:36:30
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <format>		// c++ 20
#include <print>		// c++ 23
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	int a[100];			// 앞으로 T[N] 은 사용하지 않는다.

	for (int& num : a)
		num = uid(dre);

	for (int& num : a)
		std::print(std::cout, "{:8}", num);
	std::cout << '\n';

	// [문제] a의 값 중 가장 큰 값을 찾아 화면에 출력하라.

	std::cout << "최대값: " << *std::max_element(std::begin(a), std::end(a)) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 2:57:26
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array>
#include <fstream>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 만들어라.
// [0, 9'9999] 범위의 값을 갖는 int 100개에 할당하라.
// 화면에 값을 출력한다.

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	std::array<int, 100> a;			// T[N] 대신 array<T, N>을 사용.
	
	for (int& num : a)
		num = uid(dre);

	// [문제] 파일 "int값들.txt"에 a의 int값을 모두 저장하라.
	std::ofstream out{ "int값들.txt" };			// RAII
	for (int num : a)
		print(out, "{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-12 화요일 오후 3:09:02
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 12일 화요일		(2주 1)
// 
// 많은 수의 데이터를 처리할 수 있어야...
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "int값들.txt"에는 몇 개인지 모르는 int값이 있다.
// 제일 큰 값을 찾아 화면에 출력하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "int값들.txt" };
	if (not in) 
		exit(0);
	
	std::cout << "최대값: " << *std::max_element(std::istream_iterator<int>{in}, { }) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:37:51
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

//-------------
int main(void)
//-------------
{
	std::array<int, 100> a;

	for (int num : a)
		std::cout << num << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:39:49
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	std::array<int, 100> a{1};

	for (int num : a)
		std::cout << num << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:40:36
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	for (int num : a)
		std::cout << num << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:43:25
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	for (int i = 1; i <= 100; i++)
		a[i - 1] = i;

	for (int num : a)
		std::cout << num << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:45:19
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	for (int i = 1; i <= 100; i++)
		a[i - 1] = i;

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:47:15
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 1000> a;

	int i{ 0 };
	for (int& num : a)
		num = ++i;

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 1:57:23
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include <numeric>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	std::iota(a.begin(), a.end(), 1);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:02:12
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include <numeric>
#include <fstream>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int값들.txt" };

	for (int num : a)
		std::print(out, "{:8}", num);


	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:05:19
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include <numeric>
#include <fstream>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int값들.txt" };

	for (int num : a)
		std::print(out, "{} ", num);

	// int 100개를 저장하기 위해 필요한 공간은?

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:25:59
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include <numeric>
#include <fstream>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int값들.txt" };

	out.write((char*)a.data(), a.size()*sizeof(int));

	// int 100개를 저장하기 위해 필요한 공간은?

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:36:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <print>
#include <numeric>
#include <fstream>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 100> a;

	std::iota(a.begin(), a.end(), 1);

	// 읽기 모드로 열어도 저수준 출력에는 아무 지장이 없다.
	// 다만, 운영체제가 중간에 개입하여 1바이트가 추가된다.
	std::ofstream out{ "int값들.txt", std::ios::binary };

	out.write((char*)a.data(), a.size()*sizeof(int));

	// int 100개를 저장하기 위해 필요한 공간은?

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:44:58
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <random>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int값을 1부터 시작하는 정수로 채워라.
// 파일에 "int값을.txt"에 기록하라.

// 데이터 세그먼트에서 초기화 되지 않은 공간에 위치.
// std::array<int, 100> a;

std::default_random_engine dre;
std::uniform_int_distribution uid(0, 9'9999);

//-------------
int main(void)
//-------------
{
	// int 자료형은 초기화를 하지 않았을 경우 공간 확보만 함.
	// {}는 0으로 초기화가 아니라 디폴트 값으로 초기화 하는 것. 0이 나오는 것은 0이 디폴트 값이기 때문.
	
	std::array<int, 1000> a;

	for (int& num : a)
		num = uid(dre);

	// 텍스트 모드로 열어도 저수준 출력에는 아무 지장이 없다.
	// 다만, 운영체제가 중간에 개입하여 1바이트가 추가된다.
	std::ofstream out{ "int값들", std::ios::binary };

	out.write((char*)a.data(), a.size()*sizeof(int));

	// int 100개를 저장하기 위해 필요한 공간은?

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:54:11
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "int값들" };
	if (!in) exit(0);

	std::cout << *std::max_element(std::istream_iterator<int>{in}, { }) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:54:49
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "int값들" };
	if (not in) exit(0);

	std::cout << *std::max_element(std::istream_iterator<int>{in}, { }) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 2:57:24
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "int값들", std::ios::binary};
	if (not in) exit(0);

	std::cout << *std::max_element(std::istream_iterator<int>{in}, { }) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 3:04:01
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "int값들", std::ios::binary};
	if (not in) exit(0);

	std::array<int, 1000> a;

	in.read((char*)a.data(), a.size() * sizeof(int));

	std::cout << *std::max_element(a.begin(), a.end()) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 3:10:29
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <random>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

std::default_random_engine dre;
std::uniform_int_distribution<int> uidC{ 'a', 'z' };
std::uniform_int_distribution uidNum{ -9999, 9999 };

class Dog
{
	char c{ static_cast<char>(uidC(dre)) };
	int num{ uidNum(dre) };
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog)
	{
		return os << "글자: " << dog.c << ", 숫자: " << dog.num;
	}
};

//-------------
int main(void)
//-------------
{
	std::array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
		std::cout<< dog << '\n';

	// 

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-14 목요일 오후 3:12:02
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <random>
#include "save.h"

// [문제] int 1000개를 "int값들"에 저장하였다.
// 파일은 binary 모드로 열었고
// 값은 메모리 크기 그대로 4'000 바이트를 기록하였다.
// int값 중 제일 큰 값을 찾아 화면에 출력하라.

std::default_random_engine dre;
std::uniform_int_distribution<int> uidC{ 'a', 'z' };
std::uniform_int_distribution uidNum{ -9999, 9999 };

class Dog
{
	char c{ static_cast<char>(uidC(dre)) };
	int num{ uidNum(dre) };
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog)
	{
		return os << "글자: " << dog.c << ", 숫자: " << dog.num;
	}
};

//-------------
int main(void)
//-------------
{
	std::array<Dog, 100> dogs;

	for (const Dog& dog : dogs)
		std::cout<< dog << '\n';

	// 
	std::ofstream out{ "개들", std::ios::binary };
	out.write((char*)dogs.data(), sizeof(Dog)*dogs.size());

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:45:16
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "개들" };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:45:23
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "개들" };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:46:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:46:56
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}

	Dog dog;

	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:49:07
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	Dog dog;

	for (int i = 0; i < 100; ++i) {
		in.read((char*)&dog, sizeof(Dog));
		dog.show();
	}

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 1:57:28
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이 write 함수로 sizeof(Dog)*100 바이트를 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	std::array <Dog, 100> dogs;
	// 1. dogs.data()	<- 항상 이 방법을 고수
	// 2. &dogs[0]
	// 3. &dogs
	in.read((char*)dogs.data(), sizeof(Dog) * 100);

	for (const Dog& dog : dogs)
		dog.show();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:25:31
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	Dog dog;
	int cnt{};
	while (in >> dog)
		++cnt;

	std::cout << "읽은 Dog 개수 - " << cnt << '\n';
	dog.show();

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	Dog maxDog;
	int maxValue{ std::numeric_limits<int>::min() };
	for (const Dog& dog : dogs) {
		if (dog.getNum() > maxValue) {
			maxValue = dog.getNum();
			maxDog = dog;
		}
	}

	std::cout << "num값이 가장 큰 Dog" << '\n';
	maxDog.show();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:43:49
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	Dog dog;
	int cnt{};
	while (in >> dog)
		++cnt;

	std::cout << "읽은 Dog 개수 - " << cnt << '\n';
	dog.show();

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	auto pos = std::max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});

	std::cout << "num값이 가장 큰 Dog" << '\n';
	pos->show();
	// Dog, c-M, num-1559150592

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:44:17
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	Dog dog;
	int cnt{};
	while (in >> dog)
		++cnt;

	std::cout << "읽은 Dog 개수 - " << cnt << '\n';
	dog.show();

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	auto pos = std::max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});

	std::cout << "num값이 가장 큰 Dog" << '\n';
	pos->show();
	// Dog, c-M, num-1559150592

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:44:21
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	Dog dog;
	int cnt{};
	while (in >> dog)
		++cnt;

	std::cout << "읽은 Dog 개수 - " << cnt << '\n';
	dog.show();

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	auto pos = std::max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});

	std::cout << "num값이 가장 큰 Dog" << '\n';
	pos->show();
	// Dog, c-M, num-1559150592

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:44:25
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 큰 Dog 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	Dog dog;
	int cnt{};
	while (in >> dog)
		++cnt;

	std::cout << "읽은 Dog 개수 - " << cnt << '\n';
	dog.show();

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	auto pos = std::max_element(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});

	std::cout << "num값이 가장 큰 Dog" << '\n';
	pos->show();
	// Dog, c-M, num-1559150592

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 2:59:59
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	int cnt{};
	for (const Dog& dog : dogs) {
		if (dog.getNum() < 1'0000)
			++cnt;
	}
	std::cout << "10000 미만 개수 " << cnt << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-19 화요일 오후 3:07:24
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 14일 목요일		(2주 2)
// 
// FILE I/O text/binary - high/low level
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.
 
class Dog
{
private:
	char c;
	int num;
public:
	int getNum() const {
		return num;
	}
	void show() const {
		std::cout << "Dog, c-" << c << ", num-" << num << '\n';
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//-------------
int main(void)
//-------------
{
	// 꼭 바이너리 모드로 읽을 것
	std::ifstream in{ "개들", std::ios::binary };
	if (not in) {
		std::cout << "열 수 없다" << '\n';
		return 0;
	}
	// 100번 째 Dog, c-i, num--2288

	// in 파일의 크기를 filesystem을 이용하여 얻는다.
	// 파일사이즈/sizeof(Dog) -> 100개
	// new Dog[num];

	std::array<Dog, 100> dogs;
	in.read(reinterpret_cast<char*>(dogs.data()), sizeof(Dog) * 100);

	int num = std::count_if(dogs.begin(), dogs.end(), [](const Dog& dog) {
		if (1'0000 > dog.getNum())
			return true;
		return false;
		});
	std::cout << "개수 - " << num << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:33:25
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:34:57
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	// 000000916896FE30

	for(int a : a)
		std::cout << "array<int, 10> - " << std::addressof(a) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:35:24
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	// 000000916896FE30

	for(int addr : a)
		std::cout << "array<int, 10> - " << std::addressof(a) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:35:36
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	// 000000916896FE30

	for(int addr : a)
		std::cout << "array<int, 10> - " << std::addressof(addr) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:35:45
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	// 000000916896FE30

	for(int addr : a)
		std::cout << "array<int, 10> - " << std::addressof(addr) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:36:46
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	// 000000916896FE30

	for(int addr : a)
		std::cout << "array<int, 10> - " << std::addressof(addr) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:38:29
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for(int& num : a)
		std::cout << std::addressof(num) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:41:05
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n' << '\n';

	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:41:51
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:45:49
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	std::cout << '\n';
	int num;
	std::cout << std::addressof(num) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:47:12
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

//-------------
int main(void)
//-------------
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';

	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:50:44
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{
	std::cout << '\n';
	int num;
	std::cout << std::addressof(num) << '\n';
}

//-------------
int main(void)
//-------------
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';

	f();

	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:51:09
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';
}

//-------------
int main(void)
//-------------
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';

	f();

	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:52:35
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f(int a)
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << a << '\n';
	std::cout << '\n';
}

//-------------
int main(void)
//-------------
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';

	f(123);

	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 1:53:13
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f(int a)
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << std::addressof(a) << '\n';
	std::cout << '\n';
}

//-------------
int main(void)
//-------------
{
	int num;
	std::cout << std::addressof(num) << '\n';
	std::cout << '\n';

	f(123);

	std::array<int, 10> a;
	std::cout << "STACK" << '\n';
	std::cout << "array<int, 10> - " << std::addressof(a) << '\n';
	std::cout << "a[0] - a[9]" << '\n';
	for (int& num : a)
		std::cout << std::addressof(num) << '\n';

	std::cout << '\n';
	std::string s{ "스트링" };
	std::cout << std::addressof(s) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:13:33
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{

}

//-------------
int main(void)
//-------------
{
	int num;
	
	(*f)();		//f()

	std::cout << "STACK" << '\n';
	std::cout << "	    - num " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	   - main " << std::addressof(main) << '\n';
	std::cout << "	   - f " << std::addressof(main) << '\n';
	std::cout << "	   - save " << std::addressof(main) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:14:01
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{

}

//-------------
int main(void)
//-------------
{
	int num;
	
	(*f)();		//f()

	std::cout << "STACK" << '\n';
	std::cout << "	    - num  " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	    - main " << std::addressof(main) << '\n';
	std::cout << "	    - f    " << std::addressof(main) << '\n';
	std::cout << "	    - save " << std::addressof(main) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:14:33
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{

}

//-------------
int main(void)
//-------------
{
	int num;
	
	(*f)();		//f()

	std::cout << "STACK" << '\n';
	std::cout << "	    - num  " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	    - main " << std::addressof(main) << '\n';
	std::cout << "	    - f    " << std::addressof(f) << '\n';
	std::cout << "	    - save " << std::addressof(save) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:16:19
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

void f()
{

}

//-------------
int main(void)
//-------------
{
	long long val{ 0x7F'FF'FF'FF'FF'FF };
	std::cout << "사용할 수 있는 최대 메모리 한계 - " << val << '\n';
	int num;
	
	(*f)();		//f()

	std::cout << "STACK" << '\n';
	std::cout << "	    - num  " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	    - main " << std::addressof(main) << '\n';
	std::cout << "	    - f    " << std::addressof(f) << '\n';
	std::cout << "	    - save " << std::addressof(save) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:22:29
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

int num;

//-------------
int main(void)
//-------------
{
	int num;
	
	std::cout << "STACK" << '\n';
	std::cout << "	    - num        " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	    - main       " << std::addressof(main) << '\n';

	std::cout << '\n';
	std::cout << "DATA" << '\n';
	std::cout << "	    - global num " << std::addressof(::num) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:36:06
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <string>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

int num;

//-------------
int main(void)
//-------------
{
	int num;
	
	// 내가 요청한 데이터 타입의 포인터 타입을 리턴 ex)int*.
	int* p = new int;

	std::cout << "STACK" << '\n';
	std::cout << "	    - num        " << std::addressof(num) << '\n';

	std::cout << '\n';
	std::cout << "free store" << '\n';
	std::cout << "	    - p          " << std::addressof(*p) << '\n';

	std::cout << '\n';
	std::cout << "CODE" << '\n';
	std::cout << "	    - main       " << std::addressof(main) << '\n';

	std::cout << '\n';
	std::cout << "DATA" << '\n';
	std::cout << "	    - global num " << std::addressof(::num) << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:54:04
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char ga[0x7f'ff'ff'ff];

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:54:31
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c[0x7f'ff'ff'ff];

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:54:45
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[0x7f'ff'ff'ff];
char c2[0x7f'ff'ff'ff];

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:55:03
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[0x7f'ff'ff'ff];
char c2[0x7f'ff'ff'ff];
char c3[0x7f'ff'ff'ff];
char c4[0x7f'ff'ff'ff];

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:55:17
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[0x7f'ff'ff'ff];
char c2[0x7f'ff'ff'ff];
char c3[0x7f'ff'ff'ff];
char c4[0x7f'ff'ff'ff];
char c5[0x7f'ff'ff'ff];

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 2:58:26
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[0x7f'ff'ff'ff]{1};

//-------------
int main(void)
//-------------
{
	std::cout << "사용할 수 있는 최대 배열의 크기 - " << 0x7f'ff'ff'ff << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 3:01:28
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[0x6f'ff'ff'ff]{1};

//-------------
int main(void)
//-------------
{
	c1[12345678] = 333;
	std::cout << c1[12345678] << '\n';
	std::cout << c1[0] << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 3:03:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

char c1[1'000'000'000]{1};
char c2[1'000'000'000]{1};
char c3[1'000'000'000]{1};
char c4[1'000'000'000]{1};

//-------------
int main(void)
//-------------
{
	c1[12345678] = 333;
	std::cout << c1[12345678] << '\n';
	std::cout << c1[0] << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 3:06:05
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

int a[1'000'000];

//-------------
int main(void)
//-------------
{
	std::cout << a[999'999] << '\n';
	std::cout << a[0] << '\n';
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-21 목요일 오후 3:06:26
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 21일 목요일		(3주 2)
// 
// 실행파일의 메모리 구조 - STACK CODE DATA free-store
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] "개들"에는 class Dog 객체 100개가 기록되어 있다.
// 파일은 binary 모드이고 모든 객체를 한 번의 write()로 기록하였다.
// 파일을 읽어 가장 num값이 1'0000미만인 Dog 객체는 몇 개인지 정보를 화면에 출력하라.
// class Dog의 멤버는 다음과 같다.

int a[1'000'000]{1};

//-------------
int main(void)
//-------------
{
	std::cout << a[999'999] << '\n';
	std::cout << a[0] << '\n';
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-26 화요일 오후 2:58:35
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 26일 화요일		(4주 1)
// 
// free-store - RAII
// 
// C++언어에서 사용하지 않도록 권고
// - char*		-->	string
// - T[N]		-->	array<T, N>
// - T*(raw *)	-->	unique_ptr, shared_ptr(스마트 포인터)
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	int* p;

	p = new int[100];
	
	save("STL.cpp");

	delete[]p;
	// 1. momory leak
	// 2. dangling pointer
	// 3. 제어경로가 복잡해 질 경우 문제 발생

	// -> RAII
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:37:27
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// Dog를 free store에 만들어 본다.

	std::unique_ptr<Dog> p{ new Dog };

	new Dog;
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:37:45
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

//-------------
int main(void)
//-------------
{
	// Dog를 free store에 만들어 본다.

	std::unique_ptr<Dog> p{ new Dog };

	new Dog;
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:38:33
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// Dog를 free store에 만들어 본다.

	std::unique_ptr<Dog> p{ new Dog };

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:43:38
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// Dog를 10객체를 free store에 만들어 본다.

	std::unique_ptr<Dog[]> p{new Dog[10]};

	save("STL.cpp");
	std::cout << "메인이 끝" << '\n';		// 이 문장 출력 후 p가 가리키는 객체 소멸
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:46:29
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// 이 main()은 문제가 없지만 불편하다. -> new와 짝이 맞는 delete가 없는데?

	std::unique_ptr<Dog[]> p{new Dog[10]};

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:48:52
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// 이 main()은 문제가 없지만 불편하다. -> new와 짝이 맞는 delete가 없는데?

	std::unique_ptr<Dog> p = std::make_unique<Dog>();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:49:28
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// 이 main()은 문제가 없지만 불편하다. -> new와 짝이 맞는 delete가 없는데?
	// 편의함수 make_unique를 사용한다.

	std::unique_ptr<Dog> p = std::make_unique<Dog>();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 1:50:11
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// unique_ptr 사용 - 자원을 독점 소유(ownership)
//-------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

class Dog
{
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }
};

class 스마트포인터 {
private:
	Dog* p;
public:
	스마트포인터(Dog* p) : p(p) {}
	~스마트포인터() { delete p; }
};

void f()
{
	std::cout << "f 시작" << '\n';
	스마트포인터 p(new Dog);
	throw 1234;
	std::cout << "f 끝" << '\n';
}

//-------------
int main(void)
//-------------
{
	// 이 main()은 문제가 없지만 불편하다. -> new와 짝이 맞는 delete가 없는데?
	// 편의함수 make_unique를 사용한다.

	std::unique_ptr<Dog[]> p = std::make_unique<Dog[]>(10);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:04:10
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	char c;
	while (in.read(&c, sizeof(char)))
		std::cout << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:06:19
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt" };

	char c;
	while (in.read(&c, sizeof(char)))
		std::cout << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:07:14
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt" };

	char c;
	while (in.read(&c, sizeof(char)))
		std::cout << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:07:44
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	char c;
	while (in.read(&c, sizeof(char)))
		std::cout << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:09:14
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	char c;
	while (in.read(&c, sizeof(char)))
		std::cout << (c = toupper(c));

	std::ofstream out{ "STL대문자.txt", std::ios::binary };
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:11:02
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	char c;
	while (in.read(&c, sizeof(char)))
		out << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:11:23
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt"};

	char c;
	while (in.read(&c, sizeof(char)))
		out << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:11:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	char c;
	while (in.read(&c, sizeof(char)))
		out << (c = toupper(c));
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:20:12
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	char c;
	while (in.read(&c, sizeof(char)))
		out << (c = toupper(c));

	std::transform(std::istream_iterator<char>{in}, { },
		std::ostreambuf_iterator<char>{std::cout}, [] (char c) {
			return toupper(c);
		});
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:20:30
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };
	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	std::transform(std::istream_iterator<char>{in}, { },
		std::ostreambuf_iterator<char>{std::cout}, [] (char c) {
			return toupper(c);
		});
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:21:21
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "STL.cpp"를 읽어 모든 소문자를 대문자로 변환하여
// "STL대문자.txt"에 저장하라.

//-------------
int main(void)
//-------------
{
	std::ifstream in { "STL.cpp", std::ios::binary };

	if (not in)
		return 1234567890;

	std::ofstream out{ "STL대문자.txt", std::ios::binary};

	std::transform(std::istreambuf_iterator<char>{in}, { },
		std::ostreambuf_iterator<char>{std::cout}, [] (char c) {
			return toupper(c);
		});
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:26:01
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

//-------------
int main(void)
//-------------
{
	
	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:41:01
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <cstdlib>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 2:55:48
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <cstdlib>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	int 정렬방법(const void*, const void*);
	qsort(a.data(), a.size(), sizeof(int), 정렬방법);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 3:00:31
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <cstdlib>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	int 정렬방법(const void*, const void*);
	qsort(a.data(), a.size(), sizeof(int), 정렬방법);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 3:01:01
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	int 정렬방법(const void*, const void*);
	qsort(a.data(), a.size(), sizeof(int), 정렬방법);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 3:02:44
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	//int 정렬방법(const void*, const void*);
	qsort(a.data(), a.size(), sizeof(int), [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
		});

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 3:08:02
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int 정렬방법(const void*, const void*);

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	std::cout << typeid(정렬방법).name() << '\n';

	qsort(a.data(), a.size(), sizeof(int), 정렬방법);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-03-28 목요일 오후 3:09:49
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		3월 28일 목요일		(4주 2)
// 
// callable type -> 정렬 예제에서 시작
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 qsort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int 정렬방법(const void*, const void*);

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// 여기서 qsort로 정렬한다 - qsort는 C함수이지만 generic 함수이다.
	// qsort( 어디를, 몇개야, 한개의 크기는, 너 만의 정렬방법을 알려줘 );

	int (*함수)(const void*, const void*)  = 정렬방법;

	qsort(a.data(), a.size(), sizeof(int), 함수);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 1:37:34
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int 정렬방법(const void*, const void*);

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 오름차순으로 정렬하라.

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 1:53:30
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int 정렬방법(const void*, const void*);

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 오름차순으로 정렬하라.
	std::sort(a.begin(), a.end()); 

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 1:54:00
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int 정렬방법(const void*, const void*);

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 오름차순으로 정렬하라. (Defalt 오름차순)
	std::sort(a.begin(), a.end()); 

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

int 정렬방법(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 1:56:25
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

bool 정렬방법(int, int );

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	std::sort(a.begin(), a.end(), 정렬방법); 

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

bool 정렬방법(int a, int b)
{
	return a > b;		// descending order
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 1:57:19
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 123456> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

bool 정렬방법(int, int );

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	std::sort(a.begin(), a.end(), 정렬방법); 

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

bool 정렬방법(int a, int b)
{
	return a > b;		// descending order
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:01:34
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	std::sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;			// 람다 사용, 가독성이 좋아짐.
		});

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:07:09
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:08:03
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	std::sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		std::print("{:8}", num);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:15:52
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:16:15
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:16:43
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:17:42
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:18:05
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:18:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 100> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:19:26
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 1000> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

class Dog
{
private:
	int cnt{};
public:
	bool operator()(int a, int b) {
		++cnt;
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:20:24
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//-------------------------------------------------------------------
#include <iostream>
#include <array>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"

// [문제] int 100개를 저장할 공간을 확보하라.
// int 100개의 값을 [1, 10000] 랜덤값으로 설정하라.
// int값 100개를 C의 std::sort를 사용하여 오름차순으로 정렬하라.
// 정렬결과를 한 줄에 10개씩 화면에 출력하라.

std::array<int, 1000> a;
std::uniform_int_distribution uid{1, 10000};
std::default_random_engine dre;

int cnt{};

class Dog
{
public:
	bool operator()(int a, int b) {
		++cnt;
		return a > b;
	}
	void showResult() const {
		std::cout << cnt << "번 비교함수 호출됨" << '\n';
	}
};

//-------------
int main(void)
//-------------
{
	for (int& num : a)
		num = uid(dre);

	// std::sort를 사용하여 a를 내림차순으로 정렬하라.
	Dog dog;
	std::sort(a.begin(), a.end(), dog);

	for (int num : a)
		std::print("{:8}", num);

	dog.showResult();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:27:27
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	[]() {};

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:28:41
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	[]() {
		std::cout << "안녕? 난 람다라고 해! 잘 부탁해" << '\n';
		};

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:29:52
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	[]() {
		std::cout << "안녕? 난 람다라고 해! 잘 부탁해" << '\n';
		}();

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:30:38
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	[](int a ,int b) {
		std::cout << "안녕? 난 람다라고 해! 잘 부탁해 - " << a+b << '\n';
		}(3, 4);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:33:06
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	auto 람다 = []() {
		std::cout << "람다입니다" << '\n';
		};

	std::cout << "람다의 정체 - " << typeid(람다).name() << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:38:24
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

//-------------
int main(void)
//-------------
{
	auto 람다1 = []() {
		std::cout << "람다입니다" << '\n';
		};
	
	auto 람다2 = []() {
		std::cout << "람다입니다" << '\n';
		};

	std::cout << typeid(람다1).name() << '\n';
	std::cout << typeid(람다2).name() << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:41:54
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

auto 람다2 = []() {
	std::cout << "람다입니다" << '\n';
	};

//-------------
int main(void)
//-------------
{
	auto 람다1 = []() {
		std::cout << "람다입니다" << '\n';
		};

	std::cout << typeid(람다1).name() << '\n';
	std::cout << typeid(람다2).name() << '\n';

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:50:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

void jump()
{
	std::cout << "점프" << '\n';
}

void slide()
{
	std::cout << "슬라이드" << '\n';
}

//-------------
int main(void)
//-------------
{
	save("STL.cpp");

	void (*f)() = jump;

	while (true) {
		// s를 누르면 기능을 토글
		std::cout << "키를 누르면 기능을 수행 - ";
		char c;
		std::cin >> c;

		if ('a' == c) {
			f();
		}
		if ('s' == c) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}

	
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:53:42
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

void f(int(*x)(int, int))
{
	std::cout << x(3, 5) << '\n';
}

int x(int a, int b)
{
	return a * b;
}

//-------------
int main(void)
//-------------
{
	f([](int a, int b)->int { return 333; });

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:53:53
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
//-------------------------------------------------------------------
#include <iostream>
#include "save.h"

void f(int(*x)(int, int))
{
	std::cout << x(3, 5) << '\n';
}

int x(int a, int b)
{
	return a * b;
}

//-------------
int main(void)
//-------------
{
	f(x);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:58:25
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
// 
// --> 모든 호출가능타입을 대표하는 클래스 -> function
//-------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"

void f(std::function<int(int, int)> x)
{
	std::cout << x(3, 5) << '\n';
}

int x(int a, int b)
{
	return a * b;
}

//-------------
int main(void)
//-------------
{
	f([](int a, int b)->int { return 333; });

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 2:58:56
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
// 
// callable type -> 정렬 예제에서 시작
// 
// 많은 데이터를 정렬할 때 - 정렬기준을 어떻게 sort 함수에 전달하지?
// 1. 함수 포인터
// 2. 람다
// 3. 함수 객체( function object ) - ()연산자를 오버로딩한 한 클래스 객체
//    상태를 가질 수 있다.
// 
// --> 모든 호출가능타입을 대표하는 클래스 -> function
//-------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"

void f(std::function<int(int, int)> x)
{
	std::cout << x(3, 5) << '\n';
}

int x(int a, int b)
{
	return a * b;
}

//-------------
int main(void)
//-------------
{
	f([](int a, int b)->int { return 333; });
	f(x);

	save("STL.cpp");
}

=========================================================
STL.cpp:, 2024-04-02 화요일 오후 3:10:44
=========================================================

//-------------------------------------------------------------------
// 2024 1학기 STL 화56목56		4월 2일 화요일		(5주 1)
// 
// 4월 25일 (8주 1일) - 중간시험
//-------------------------------------------------------------------
#include <iostream>
#include <cstring>
#include "save.h"

class String
{
private:
	size_t len{};
	std::unique_ptr<char[]> p{};
public:
	String(const char* str) : len(strlen(str)) {
		p = std::make_unique<char[]>(len);
		memcpy(p.get(), str, len);
	}
	friend std::ostream& operator<<(std::ostream& os, const String& s) {
		for (size_t i = 0; i < s.len; i++)
			os << s.p.get()[i];
		return os;
	}
};

//-------------
int main(void)
//-------------
{
	String s{ "STL 공부를 위한 클래스" };

	std::cout << s << '\n';

	save("STL.cpp");
}